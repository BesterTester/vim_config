" =========================
" KEY TO FUNCTION MAPPINGS
" =========================

" Programming specific mappings
execute 'nnoremap ' . g:prog_leader . 'b :call CompileAndRunVSplit()<CR>'
execute 'nnoremap ' . g:prog_leader . 'r :call RerunInVSplit()<CR>'
execute 'nnoremap ' . g:prog_leader . 'c :call ToggleComment()<CR>'


" =========================
" FUNCTIONS
" =========================

let g:out_esc       = ''

" Save the current buffer and run the gcc compiler with the file
function! CompileC()
    update
    let g:filename = expand('%:p:r')
    let compile_cmd = 'gcc ' . shellescape(expand('%:p')) . ' -o ' . shellescape(g:filename) . " -lm"
    echo "Compiling: " . compile_cmd
    let result = system(compile_cmd)
    if v:shell_error == 0
        echo "Compilation successful. Running..."
        execute 'vertical rightbelow terminal ' . g:filename
    else
        echo "Compilation failed!"
        echo result
    endif
endfunction


" Rerun the last compiled C program
function! ReRunC()
    if exists('g:filename') && !empty(g:filename)
        execute 'quit'
        execute 'vertical rightbelow terminal ' . g:filename
    else
        echo "Could not execute file: " . g:filename
    endif
endfunction


function! CompileAndRunVSplit()
    update
    let l:src           = expand('%:p')
    let l:src_esc       = shellescape(l:src)
    let l:out           = expand('%:p:r')
    let g:out_esc       = shellescape(l:out)
    let l:compile_cmd   = 'bash -lc "gcc  ' . l:src_esc . ' -o ' . g:out_esc . ' -lm && ' . g:out_esc . '"'
    execute 'vertical rightbelow terminal ' . l:compile_cmd
endfunction


function! RerunInVSplit()
    "   update
    "   let l:src           = expand('%:p')
    "   let l:src_esc       = shellescape(l:src)
    "   let l:out           = expand('%:p:r')
    "   let g:out_esc       = shellescape(l:out)
    let l:rerun_cmd   = 'bash -lc "' . g:out_esc . '"'
    execute 'quit'
    execute 'vertical rightbelow terminal ' . l:rerun_cmd
endfunction


" Toggle C/C++ comment on current line
function! ToggleComment()
    let l:line = getline('.')
    let l:stripped = substitute(l:line, '^\s*', '', '')
    
    if l:stripped =~# '^//'
        " Line is commented - remove comment
        let l:new_line = substitute(l:line, '^\(\s*\)//\s*', '\1', '')
        call setline('.', l:new_line)
        echo "Comment removed"
    else
        " Line is not commented - add comment
        let l:indent = matchstr(l:line, '^\s*')
        let l:new_line = l:indent . '// ' . l:stripped
        call setline('.', l:new_line)
        echo "Comment added"
    endif
endfunction


